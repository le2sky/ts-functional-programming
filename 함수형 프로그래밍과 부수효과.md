# 함수형 프로그래밍과 부수효과

어떤 입력이 나오면 어떤 출력이 나오는지 명확하고 깜짝놀라는 부수효과가 없는 함수형 프로그래밍은 정직하다. -마이클 페더스

```
람다 대수는 튜링 완전성을 만족시키며, 보편 튜링 기계와 동치이다.
```

## 1. 함수형 프로그래밍

작은 순수 함수들로 분해하고 합성하여 더 큰 프로그램을 만드는 것

**핵심 개념 2가지** :

- 함수를 합성해서 복잡한 프로그램을 쉽게 만들기
- 부수효과를 공통적인 방법으로 추상화

## 2. 명령형 vs 함수형(선언형)

**명령형** : 어떻게 하는가를 명시, 기계에게 효율적인 방식, 상태 변경, 부수효과, 복잡한 흐름

**선언형** : 인간이 이해하기 쉬운 방식, 부수효과가 없는 순수 함수, 작고 예측하기 쉬움

## 3. 객체지향과 함수형의 차이

```
- 명사의 왕국인 객체지향 세계와 동사의 왕국인 함수형 세계
- 100개의 함수를 하나의 자료구조에 적용하는 것이 10개의 함수를 10개의 자료구조를 적용하는 것보다 낫다. - 엘런 펄리스
- 객체지향 프로그래밍은 움직이는 부분을 캡슐화하여 코드 이해를 돕고, 함수형 프로그래밍은 움직이는 부분을 최소화하여 코드 이해를 돕는다. -마이클 페더스
- OOP와 함수적 계산은 완전히 조화될 수 있다.
```

## 4. 부수효과 (Side effect)

값을 반환하는 것 외에 부수적으로 일으키는 효과. 명령형 프로그래밍은 부작용을 사용해 프로그램이 동작하게 하는 것으로 알려져 있고, 함수형 프로그래밍은 부작용을 최소화하는 것으로 알려져 있다.

    부수효과 예시
    - 변수나 상태를 바꾸거나 수정
    - 화면이나 파일에 데이터를 쓰는 IO작업
    - 다른 부수효과가 있는 함수나 상태 값에 의존
    => 기계와 저수준에 최적화된 명령형 방식

컴퓨터는 메모리가 허용하는 선에서 많은 변수를 선언 수정 등 사이드 이펙트를 허락한다. 하지만 인간이 한번에 생각할 수 있는 작업 기억 용량은 3-5개 정도에 불과하기 때문에 변화하는 상태를 기억하기 어렵다.

코드 실행 순서, 횟수, 분기에 따라 결과가 다르거나, 비동기, 병렬 처리, 전역 상태까지 더해진다면 코드를 이해하고 결과를 예측하기 어려워진다. 함수형 프로그래밍은 이러한 부수효과를 분리하고 추상화한다.

## 5. 순수 함수(Pure function)

**함수** : 주어진 입력을 기반으로 부수효과의 발생과 함께 계산된 값을 리턴하는 서브 루틴

**순수 함수** : 똑같은 매개변수(입력)를 받으면 항상 같은 값을 반환하는 함수. 부수효과를 일으키지 않는다.

부수효과가 있는 함수는 합성하기 까다롭다. 함수형 프로그래밍에서 함수 합성은 순수 함수로 이루어진다.

## 6. 부수효과를 다루는 법

**합성하기 어려운 부수효과 : for문**

```js
function sum_1_to_100(){
    let sum = 0;
    for(let i = 1; i <= 100; i++>){
        sum +=i;
    }
    return sum;
}
console.log(sum_1_to_100());


1. for, while은 상태를 변경하고 불변성을 위반하기 때문에 함수형 프로그래밍에서는 원칙적으로 사용할 수 없다. 함수형에서는 재귀를 사용

2. 위 함수는 상태가 변하며, 복잡해서 실수하기 쉬운 명령형 프로그래밍이며 합성하기 어렵다.
```

**순수하지만 장황한 재귀**

```js
function sum_1_to_100() {
  function go(sum, i) {
    if (i > 100) return sum;
    return go(sum + i, i + 1);
  }
  return go(0, 1);
}
console.log(sum_1_to_100());

1. 순수하긴 한데... 복잡함
```

**일반화된 방식으로 추상화**

```js
function loop(fn, acc, list) {
  if (list.length === 0) return acc;
  const [head, ...tail] = list;
  return loop(fn, fn(acc, head), tail);
}

const range = (start, end) =>
  Array.from({ length: end - start + 1 }, (_, index) => index + start);

const plus = (a,b) => a + b;

console.log(loop(plus, 0, range(1,100)))


1. 반복 가능한 자료구조
2. 추상화된 함수 활용
=> 순수하고 선언적 합성이 쉽다.
```

함수형 프로그래밍에서는 함수는 값과 특별한 구별이 없이 인자로 넘기거나 리턴할 수 있는 일급 객체이고 이러한 특성을 이용해서 고차함수를 구현할 수 있기 때문이다.

```
효과를 안전하게 추상화하는 것의 장점

- 명확하고 순수한 Effect
- 효과와 계산이 직교하게 분리
- 재사용하기 쉬운 추상화
- 단순하고 일관된 인터페이스
```

# 함수형 프로그래밍에서의 비동기

비동기는 실행흐름이 순차적이지 않아서 까다롭다.

## 1. 동기에서 비동기로

자바스크립트 엔진은 단일 스레드로 동작한다. 비동기가 필요한 상황은 주로 CPU에 의존하지 않은 작업을 하는 상황이다. 네트워크, IO 작업 등이 있다.

> 아래와 같은 경우에는 비동기 함수 내부의 setTimeout 안에서 동작하는 리턴값을 받을 수 없다. 이것을 콜백함수로 해결할 수 있다. 콜백함수를 사용해서 다음 작업을 실행한다. 이것을 continuation-passing style(연속 전달 방식)이라고 한다. 대조되는 것은 직접 스타일이라 한다.

id 함수는 리턴해야하는 값을 return 구문을 사용해서 돌려주고 있는 반면
cpsId는 리턴해야하는 값을 콜백함수에게 전달해주고 있다. 이것은 어떤 의미에서는
리턴이라는 구문을 ret라는 함수로 대체했다고 생각할 수 있다. 리턴구문을 사용해서
함수의 결과를 돌려줄 때는 반드시, 함수의 실행이 종료되는 마지막에 단 한번 돌려줄 수 있다는 제한 사항이 있었다. 이것은 곧 함수의 결과는 함수의 실행과 동기화 된다는 것을 의미한다.

cps에서는 리턴구문이 함수로 대체됐기 때문에 결과값을 리턴하는 동작이 함수의 실행에 동기화되지 않는다. 콜백함수를 다른 비동기함수에 전달할 수 있다면 함수의 실행이 종료되어도 비동기함수가 전달받은 콜백함수를 실행해서 값을 대신 전달하는 동작도 가능하다. 값의 전달이 리턴구문이 아닌 일반적인 함수를 통해서 이루어지기 때문에
원한다면 여러번 전달할 수 있고, 심지어 전달할 때마다 서로 다른 값을 전달할 수 있다.

```ts
const f = (str: string) => {
  setTimeout(() => {
    console.log("비동기로 출력: " + str);
    return str.length * 2; // 비동기 return을 받을 수 없음
  }, 500);
};

const g = (n: number) => {
  return n + 1;
};

const h = (x: number) => {
  return x % 3 === 0;
};

const handleError = (e: unknown) => {
  // 사용자에게 에러를 알려주는 통합 함수
  console.log("handleError: " + e);
};

const program = (s: boolean) => {
  console.log(s);
};

const greeting = (name: string) => {
  console.log("Hello, " + name);
};

const id = <A>(a: A): A => {
  return a;
};

const cpsId = <A>(a: A, ret: (a: A) => void) => {
  ret(a);
};

// continuation-passing style -> CPS
// direct style

export const main = () => {
  const a = id("test");
  console.log(a);

  cpsId("test", (a) => {
    console.log(a);
  });

  greeting("World");
  console.log("프로그램이 종료되었습니다.");
};
```

## 2. 콜백 지옥!

CPS을 쓰다보면 콜백 지옥을 만나게 된다. 함수를 순차적으로 호출하다보면, 이전 함수의 결과가 다음 함수에 필요하기 때문이다. 명령적 코드와 뒤섞이면서 코드를 파악하기 어렵다.

CPS 함수를 합성하다보면 콜백 지옥을 만난다.

```ts
/* eslint-disable no-undef, @typescript-eslint/no-unused-vars, no-unused-vars, no-lone-blocks */

const f = (str: string, ret: (x: number) => void) => {
  setTimeout(() => {
    console.log("f 호출: " + str);
    ret(str.length * 2);
  }, 500);
};

const g = (n: number, ret: (x: number) => void) => {
  setTimeout(() => {
    console.log("g 호출: " + n);
    ret(n + 1);
  }, 500);
};

const h = (x: number, ret: (x: boolean) => void) => {
  setTimeout(() => {
    console.log("h 호출: " + x);
    ret(x % 3 === 0);
  }, 500);
};

const handleError = (e: unknown) => {
  // 사용자에게 에러를 알려주는 통합 함수
  console.log("handleError: " + e);
};

const program = (s: boolean) => {
  console.log(s);
};

const greeting = (name: string) => {
  console.log("Hello, " + name);
};

export const main = () => {
  f("test", (a) => {
    g(a, (b) => {
      h(b, (c) => {
        program(c);
      });
    });
  });

  greeting("World");
  console.log("프로그램이 종료되었습니다.");
};
```

## 3. Promise

지금까지는 에러나 값의 부재를 타입으로 표현해서 값으로 다루었다.
cps를 사용하는 비동기 처리도 값으로 다룰 수 있을까?

> 임의의 타입 A의 값을 동기로 다룬다는 것은 값이 준비되어있어 즉시 다룰 수 있다. 비동기로 값을 다루는 것은 값이 언제 준비되는 지 알 수 없고, 준비되면 콜백함수를 호출해서 사용할 수 있게 해준다는 의미이다. 제네릭을 사용해서 비동기 타입을 나타낼 수 있다.

비동기함수를 커링한 이후 반환된 함수의 시그니쳐가 async 타입이 될 수 있다.

```ts
const f =
  (str: string) =>
  (ret: (x: number) => void): void => {
    setTimeout(() => {
      console.log("f 호출: " + str);
      ret(str.length * 2);
    }, 500);
  };

const g =
  (n: number) =>
  (ret: (x: number) => void): void => {
    setTimeout(() => {
      console.log("g 호출: " + n);
      ret(n + 1);
    }, 500);
  };

const h =
  (x: number) =>
  (ret: (x: boolean) => void): void => {
    setTimeout(() => {
      console.log("h 호출: " + x);
      ret(x % 3 === 0);
    }, 500);
  };
```

```ts
// Option<A> = None | Some<A>
// Try<E,A> = Failed<E> | Success<A>

type Async<A> = (ret: (x: A) => void) => void;

//다음과 같이 수정가능
const f =
  (str: string): Async<number> =>
  (ret) => {
    setTimeout(() => {
      console.log("f 호출: " + str);
      ret(str.length * 2);
    }, 500);
  };

//Async 타입의 flatMap 구현
const flatMap = <A, B>(a: Async<A>, f: (a: A) => Async<B>): Async<B> => {
  return (ret) => {
    a((a_) => {
      const b = f(a_);
      b((b_) => ret(b_));
    });
  };
};

//Resolve 구현 => cpsId 와 같은 함수
const resolve = <A>(a: A): Async<A> => {
  return (ret) => {
    ret(a);
  };
};

//Map 구현
const map = <A, B>(a: Async<A>, f: (a: A) => B): Async<B> => {
  return flatMap(a, (a_) => resolve(f(a_)));
};



//run 함수 구현
const run <A>(a: Async<A>) => {
    a(() => {return});
}


export const main = () => {
//콜백 지옥이 없어지고 명령적인 모습과 유사한 코드가 되었다.
  const a = f("test");
  const b = flatMap(a, (a_) => g(a_));
  const c = flatMap(b, (b_) => h(b_));
  const result = map(c, (c_) => program(c_));
  run(result)
};
```

> 코드의 모양이 낯익다. Try를 사용한 예제를 설명할 때 어떤 자료구조에 정해진 법칙을 만족하는 flatMap과 map함수가 있다면, 해당 자료구조를 사용하는 코드는 순차적으로 실행하는 명령적 코드와 거의 동일한 방식으로 코드의 작성이 가능하는 것을 의미한다. Async를 리턴하는 함수들을 flatMap과 map을 사용해서 연속적으로 사용한다면 비동기를 처리하는 방법에 대해서는 전혀 신경쓸 필요 없이 함수들의 순차적 호출을 명령적 코드와 거의 유사한 방식으로 코드를 작성할 수 있다.

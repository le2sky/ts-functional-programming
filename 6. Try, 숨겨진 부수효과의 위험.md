# Try, 숨겨진 부수효과의 위험

## 1. Try 타입

함수형 프로그래밍에서는 예외를 처리하는 명령적 구문이 아닌 에러를 하나의 타입으로 간주하는 방법을 선호한다.
Try Catch도 부수효과에 해당하므로 합성이 까다로움

```ts
Option<A> = None | Some<A> // 값의 부재
Try<E, R> = Failed<E> | Success<R> // 에러 가능성
```

## 2. 순수함수와 부수효과 재정의

**부수효과 :**

> 값을 반환하는 것 외에 부수적으로 일으키는 효과(side effect), 부가적으로 수행되는 동작

- "변수나 상태를 바꾸거나 수정"
- "화면이나 파일에 데이터를 쓰는 IO 작업"
- "다른 부수효과가 있는 함수나 상태 값에 의존"

  => `기계와 저수준에 최적화된 명령형 방식`

**순수함수 :**

> 똑같은 입력(매개변수)를 받으면 항상 같은 값을 반환하는 함수

- 부수효과 없음
- 수학의 함수 => `증명 가능, 안전`
- 순서나 실행 횟수랑 상관 없이, 항상 예측 가능한 결과
- 입출력 타입만 같다면 얼마든지 합성 가능

## 3. Exception Handling

> 프로그램이 정상적으로 실행될 수 없는 예외 상황을 처리하고 대응하는 방법

- 보통 프로그램 외부에서 들어오는 요인 때문
- Ex: 잘못된 사용자 입력, 요청이나 외부 상태, 통신 에러, 기기 결함, 우주선 등등

에러가 나면 다음코드를 실행하기 어렵다. 왜냐하면 우리가 작성하는 대부분 코드가 독립적이기 때문에
이전 결과값에 의존해서 다음코드를 실행한다.

에러 발생 경우 개발자가 이런 경우를 해결할 수 있게 하기 위해서 에러처리 메커니즘을 제공한다.

명령형 프로그래밍에서는 흔히 예외 처리하기 위해서 exception handling 기능을 제공한다.
직접 에러를 일으키기 위해서 throw 도 제공한다. 이러한 예외 처리 방법은 부수효과에 해당한다.

```js
const main = () => {
    try {
        ...
    } catch(e) { return 1;}
}
```

> try catch가 만약에 없다면 에러 발생 코드마다 if문을 검사해야 한다.
> 하지만 값의 부재와 마찬가지로 try catch 가 사용된 함수는 예외를 다루는 방식에 따라서
> 프로그램 실행의 흐름이 변경되는 부수효과가 발생!

=> `TryCatch : 합성이 어려움`

## 4. 참조 투명성

> 표현식(expression)을 그것을 평가한 값으로 대체하거나 또는 그 반대로 값을 표현식으로 대체하더라도
> 프로그램의 동작이 변하지 않으면 해당 표현식을 참조 투명하다고 한다.
> 표현식이 참조 투명하기 위해서는 표현식이 순수해야 한다.

=> `동일한 입력에 대한 표현식의 값은 항상 동일해야 하고 해당 평가에 부수효과가 없어야 한다.`

```
값     <=> 표현식
2400   <=> withVat(2000)
"even" <=> 42 % 2 === 0 ? "even" : "odd"
```

---

**표현식과 평가 :**

표현식(expression)은 구문(Statement)의 일종이다. `구문`은 독립적으로 실행이 가능한 코드의 조각이다.

statement:

```js
if(...) { //if 문
} else {} //else 문
for() {} //for 문
```

표현식은 값으로 평가 가능한 코드 조각이다(계산 가능). 값으로 변경 가능한 구문을 표현식이라고 하며
평가는 코드를 실행해서 값을 구하는 과정이다. 평가에 부수효과가 없다는 것은 항상 같은 코드를 실행했을 때
항상 같은 값으로 평가되어야 하고, 그 코드가 값으로 평가되는 일 이외에 다른 값을 변경하는 등의 일을 하면 안된다.

expression:

```
표현식       =>  값
4 + (7 * 8)  => 60
42 % 2 === 0 ? "even" : "odd" => "even"
```

---

**참조와 투명성 :**

> 설명하는 자료마다 조금씩 다름!
> 변수가 참조하는 값이나 표현식으로 바꾸어도 같은 값이 나온다.
> 기호가 가리키는 값으로 바꾸어도 결과는 동일하다.

어떤 변수가 사용되는 부분을 그 변수가 가리키는 표현식으로 변경하거나 또는 어떤 표현식을
그것을 가리키는 변수(즉, 참조로)로 변경해도 그 결과가 바뀌지 않는 것을 참조에 투명성이라고 한다.

=> **변수는 자신이 참조하는 표현식을 가리는 것이 없이 언제라도 변함없이 그것을 고스라니 드러내고 있기 때문에 투명하다는 표현이 어울린다.**

```js
//참조 : 어떤 값이나 표현식을 가르키는 간접적인 방법
const w = 2;
const x = 3;
const y = w * x;
const z = x - (y - y) + w; // 5;
```

---

**참조에 불투명한 경우 :**
함수형 프로그래밍에서 불변성을 강조하는 이유이다. 참조투명성을 지키지 못하기 때문에 부수효과를 예측하기 어려움

```js
// n의 값이 statement 실행마다 변경되고 있다.
let n = 0;
n = n + 1;
n = n + 1;
```

---

**다시 참조 투명성 사례 :**
참조 투명성은 수식에만 계산되는 것이 아닌 함수 호출등과 같은 모든 표현식에 적용할 수 있는 개념이다.

=> `부수효과가 없는 평가식(함수)의 사용`

참조를 평가식으로 치환해도 결과는 동일

```js
const priceOfApple = getPrice("apple");
priceOfApple + priceOfApple; // 20000

getPrice("apple") + getPrice("apple"); // 20000
```

---

**다시 참조에 불투명한 경우**

평가식(함수)에 부수효과가 포함되어 있는 경우

```js
const getPrice = (name) => {
  console.log(`${name}의 가격 조회`);
  if (name === "tomato") return 700;
  else if (name === "orange") return 15000;
  else if ((name = "apple")) return 10000;
};

const priceOfApple = getPrice("apple");
priceOfApple + priceOfApple; // console 1번 출력 이후 20000
```

log 출력 횟수가 달라짐 (프로그램 동작이 변경)

```js
getPrice("apple") + getPrice("apple");
```

=> 부수효과가 포함되어 있는 함수나 메서드는 참조에 투명하지 않기 때문에 사용방식에 주의를 기울여야 함

## 5. 참조 투명성 장점

- 표현식이 참조에 투명하다면 반복적인 표현식을 하나의 변수로 치환하여도 프로그램의 동작이 동일한 것이
  보장되기 때문에 아무리 복잡한 코드라도 안심하고 리팩토링할 수 있게된다.

- 함수를 직접 호출해야 할지, 함수를 호출한 값을 사용할지 고민할 필요가 없기 때문에 함수 합성도 마음놓고 할 수 있다.

- 이외에도 참조에 투명한 코드들은 지연 평가, 병렬 실행 등을 통한 코드 최적화가 가능하다.

=> 순수 함수형 언어들이 부수효과를 최소화하고 불변성을 강조하는 것은 코드의 대부분을 최대한 참조 투명하게 만들어
이와 같은 장점을 얻기 위함이다.

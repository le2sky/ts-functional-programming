# Try, 숨겨진 부수효과의 위험

## 1. Try 타입

함수형 프로그래밍에서는 예외를 처리하는 명령적 구문이 아닌 에러를 하나의 타입으로 간주하는 방법을 선호한다.
Try Catch도 부수효과에 해당하므로 합성이 까다로움

```ts
Option<A> = None | Some<A> // 값의 부재
Try<E, R> = Failed<E> | Success<R> // 에러 가능성
```

## 2. 순수함수와 부수효과 재정의

**부수효과 :**

> 값을 반환하는 것 외에 부수적으로 일으키는 효과(side effect), 부가적으로 수행되는 동작

- "변수나 상태를 바꾸거나 수정"
- "화면이나 파일에 데이터를 쓰는 IO 작업"
- "다른 부수효과가 있는 함수나 상태 값에 의존"

  => `기계와 저수준에 최적화된 명령형 방식`

**순수함수 :**

> 똑같은 입력(매개변수)를 받으면 항상 같은 값을 반환하는 함수

- 부수효과 없음
- 수학의 함수 => `증명 가능, 안전`
- 순서나 실행 횟수랑 상관 없이, 항상 예측 가능한 결과
- 입출력 타입만 같다면 얼마든지 합성 가능

## 3. Exception Handling

> 프로그램이 정상적으로 실행될 수 없는 예외 상황을 처리하고 대응하는 방법

- 보통 프로그램 외부에서 들어오는 요인 때문
- Ex: 잘못된 사용자 입력, 요청이나 외부 상태, 통신 에러, 기기 결함, 우주선 등등

에러가 나면 다음코드를 실행하기 어렵다. 왜냐하면 우리가 작성하는 대부분 코드가 독립적이기 때문에
이전 결과값에 의존해서 다음코드를 실행한다.

에러 발생 경우 개발자가 이런 경우를 해결할 수 있게 하기 위해서 에러처리 메커니즘을 제공한다.

명령형 프로그래밍에서는 흔히 예외 처리하기 위해서 exception handling 기능을 제공한다.
직접 에러를 일으키기 위해서 throw 도 제공한다. 이러한 예외 처리 방법은 부수효과에 해당한다.

```js
const main = () => {
    try {
        ...
    } catch(e) { return 1;}
}
```

> try catch가 만약에 없다면 에러 발생 코드마다 if문을 검사해야 한다.
> 하지만 값의 부재와 마찬가지로 try catch 가 사용된 함수는 예외를 다루는 방식에 따라서
> 프로그램 실행의 흐름이 변경되는 부수효과가 발생!

=> `TryCatch : 합성이 어려움`

## 4. 참조 투명성

> 표현식(expression)을 그것을 평가한 값으로 대체하거나 또는 그 반대로 값을 표현식으로 대체하더라도
> 프로그램의 동작이 변하지 않으면 해당 표현식을 참조 투명하다고 한다.
> 표현식이 참조 투명하기 위해서는 표현식이 순수해야 한다.

=> `동일한 입력에 대한 표현식의 값은 항상 동일해야 하고 해당 평가에 부수효과가 없어야 한다.`

```
값     <=> 표현식
2400   <=> withVat(2000)
"even" <=> 42 % 2 === 0 ? "even" : "odd"
```

---

**표현식과 평가 :**

표현식(expression)은 구문(Statement)의 일종이다. `구문`은 독립적으로 실행이 가능한 코드의 조각이다.

statement:

```js
if(...) { //if 문
} else {} //else 문
for() {} //for 문
```

표현식은 값으로 평가 가능한 코드 조각이다(계산 가능). 값으로 변경 가능한 구문을 표현식이라고 하며
평가는 코드를 실행해서 값을 구하는 과정이다. 평가에 부수효과가 없다는 것은 항상 같은 코드를 실행했을 때
항상 같은 값으로 평가되어야 하고, 그 코드가 값으로 평가되는 일 이외에 다른 값을 변경하는 등의 일을 하면 안된다.

expression:

```
표현식       =>  값
4 + (7 * 8)  => 60
42 % 2 === 0 ? "even" : "odd" => "even"
```

---

**참조와 투명성 :**

> 설명하는 자료마다 조금씩 다름!
> 변수가 참조하는 값이나 표현식으로 바꾸어도 같은 값이 나온다.
> 기호가 가리키는 값으로 바꾸어도 결과는 동일하다.

어떤 변수가 사용되는 부분을 그 변수가 가리키는 표현식으로 변경하거나 또는 어떤 표현식을
그것을 가리키는 변수(즉, 참조로)로 변경해도 그 결과가 바뀌지 않는 것을 참조에 투명성이라고 한다.

=> **변수는 자신이 참조하는 표현식을 가리는 것이 없이 언제라도 변함없이 그것을 고스라니 드러내고 있기 때문에 투명하다는 표현이 어울린다.**

```js
//참조 : 어떤 값이나 표현식을 가르키는 간접적인 방법
const w = 2;
const x = 3;
const y = w * x;
const z = x - (y - y) + w; // 5;
```

---

**참조에 불투명한 경우 :**
함수형 프로그래밍에서 불변성을 강조하는 이유이다. 참조투명성을 지키지 못하기 때문에 부수효과를 예측하기 어려움

```js
// n의 값이 statement 실행마다 변경되고 있다.
let n = 0;
n = n + 1;
n = n + 1;
```

---

**다시 참조 투명성 사례 :**
참조 투명성은 수식에만 계산되는 것이 아닌 함수 호출등과 같은 모든 표현식에 적용할 수 있는 개념이다.

=> `부수효과가 없는 평가식(함수)의 사용`

참조를 평가식으로 치환해도 결과는 동일

```js
const priceOfApple = getPrice("apple");
priceOfApple + priceOfApple; // 20000

getPrice("apple") + getPrice("apple"); // 20000
```

---

**다시 참조에 불투명한 경우**

평가식(함수)에 부수효과가 포함되어 있는 경우

```js
const getPrice = (name) => {
  console.log(`${name}의 가격 조회`);
  if (name === "tomato") return 700;
  else if (name === "orange") return 15000;
  else if ((name = "apple")) return 10000;
};

const priceOfApple = getPrice("apple");
priceOfApple + priceOfApple; // console 1번 출력 이후 20000
```

log 출력 횟수가 달라짐 (프로그램 동작이 변경)

```js
getPrice("apple") + getPrice("apple");
```

=> 부수효과가 포함되어 있는 함수나 메서드는 참조에 투명하지 않기 때문에 사용방식에 주의를 기울여야 함

## 5. 참조 투명성 장점

- 표현식이 참조에 투명하다면 반복적인 표현식을 하나의 변수로 치환하여도 프로그램의 동작이 동일한 것이
  보장되기 때문에 아무리 복잡한 코드라도 안심하고 리팩토링할 수 있게된다.

- 함수를 직접 호출해야 할지, 함수를 호출한 값을 사용할지 고민할 필요가 없기 때문에 함수 합성도 마음놓고 할 수 있다.

- 이외에도 참조에 투명한 코드들은 지연 평가, 병렬 실행 등을 통한 코드 최적화가 가능하다.

=> 순수 함수형 언어들이 부수효과를 최소화하고 불변성을 강조하는 것은 코드의 대부분을 최대한 참조 투명하게 만들어
이와 같은 장점을 얻기 위함이다.

## 6. 순수한 에러

숫자는 0으로 나눌 수 없다. 0이 인자로 들어오면 에러를 던진다. 에러를 던질 수 있는 함수지만
리턴 타입이 number로 되어 있다. 예외를 던지는 것은 타입으로부터 예외가 발생한다는 정보를 얻을 수 없다.
함수가 예외를 발생시키는지 발생시킨다면, 어떤 종류의 예외가 있는지 알려면 함수의 구현을 직접 확인하거나
별도로 예외에 대한 문서를 작성해서 알려주는 방법 밖에 없다.

```ts
const tenDivideBy = (n: number): number => {
  if (n === 0) throw new Error("0으로 나눌 수 없음");
  return 10 / n;
};

export const main = () => {
  const x = test();
  console.log(x);
  console.log("프로그램이 종료 되었습니다.");
};
```

위와 같은 경우에는 `참조에 투명하지 않다`

```ts
const test = () => {
  try {
    return tenDivideBy(0);
  } catch (e) {
    return 1;
  }
};
```

변수에 대입해도 프로그램의 동작은 일정하다.

```ts
const test = () => {
  try {
    const y = tenDivideBy(0);
    return y;
  } catch (e) {
    return 1;
  }
};
```

하지만 try 문 밖에 에러를 발생하는 표현식을 두었을 경우 프로그램이 종료되었습니다 라는 문구도 없이
종료되었다. 이를 통해서 참조에 투명하지 않음을 알 수 있다.

```ts
// 프로그램이 종료
const test = () => {
  const y = tenDivideBy(0);
  try {
    return y;
  } catch (e) {
    return 1;
  }
};
```

이러한 문제를 해결하기 위해 에러를 명시적인 값으로 돌려주는 방법이 있다. 값의 부재를 위해 만든
Option과 비슷하다.

## 7. Try 타입 자세히 보기

실패하거나 성공했을 때 각각 다른 값을 가지는 자료구조

Option을 사용했을 때, 태그를 사용해서 구분하는 방법을 사용했다. 이것은 ADT(대수 자료형)에서 합타입에 해당하는
태그드 유니언을 흉내내는 방법 중 하나이다.

Try도 동일한 방법으로 구현할 수 있다. 타입의 필드는 불변해야하기 때문에 readonly로 지정

> 사용하지 않는 타입은 never로 지정, Success 나 Failed과 같은 구체적인 타입이 아닌 그 보다 더 일반적인 타입인 Try로 만들되, 이것의 구체적인 타입을 알아야할 필요가 있을 때만 타입등을 구별해서 그에 맞는 동작을 하는게 범용성이 더 크기 때문이다.

```ts
type Success<R> = {
  readonly _tag: "success";
  readonly result: R;
};

type Failed<E> = {
  readonly _tag: "failed";
  readonly error: E;
};

export type Try<E, R> = Failed<E> | Success<R>;

export const success = <R>(result: R): Try<never, R> => ({
  _tag: "success",
  result,
});

export const failed = <E>(error: E): Try<E, never> => ({
  _tag: "failed",
  error,
});

export const isSuccess = <R>(ta: Try<unknown, R>): ta is Success<R> =>
  ta._tag === "success";

export const isFailed = <E>(ta: Try<E, unknown>): ta is Failed<E> =>
  ta._tag === "failed";
```

안쓰는 타입 파라미터가 리턴타입에서사용될 때는 never
인자의 타입에서 사용될 때는 unknown

=> typerscript의 타입시스템이 서브타입을 사용하기 때문, 인자타입과 리턴타입에 따라서 서브타이핑의 동작이 달라지기 때문이다. 이러한 동작을 공변성(covariance)과 반공변성(contravariance)이라고 한다.

```ts
export const getOrElse = <R>(ta: Try<unknown, R>, defaultValue: R) : R {
    //에러가 있을 경우 기본 값을 사용한다.
    if(isFailed(ta)) return defaultValue;
    // 결과가 성공이라면 해당 값을 사용한다.
    return ta.result;
}
```

Try에서 위와같이 getOrElse를 구현하면 반쪽 짜리이다. 왜냐하면 기본값을 결정하는 방법 때문이다.
기본값을 고정된 값을 사용하는 것이 아닌 에러값에 따라서 기본값을 다르게 정할 수 있다면 활용도가 높아질 것이다.

```ts
export const getOrElse = <E, R>(ta: Try<E, R>, defaultValue: (e: E) => R) : R {
    //에러가 있을 경우 에러에 기반하여 기본 값을 결정한다.
    if(isFailed(ta)) return defaultValue(ta.error);
    // 결과가 성공이라면 해당 값을 사용한다.
    return ta.result;
}
```

> 대수 자료형과 패턴 매칭이라는 기능을 제공하는 일부 언어들은 option이나 try 타입을 만들때, 3-4줄 정도의 타입 선언만으로도 우리가 직접 만든 여러 타입과 함수와 동일한 기능을 제공해주기도 한다. 그러한 언어를 사용하면 편할 수 있지만 꼭 그런 언어를 쓰지 않아도 비슷한 기능과 타입을 얼마든지 만들어서 사용할 수 있다.

=> 번거롭기는 해도 타입스크립트 뿐만아니라 다른언어에서도 직접 만들어서 사용 가능하다.

## 8. Option vs Try

Option과 Try는 유니언를 이용해서 두가지 타입을 하나의 타입으로 만든 자료구조이다. Option은 주로 값이 없다는 것을 나타내야 할 때이다.

```js
[1, 2, 3, 4].indexOf(5); // -1 => none
3 / 0; // infinity => none
```

- 함수의 리턴 값이 없을 경우
- 값이 없을 수도 있는 optional field

Option과 Try의 가장 큰 차이점은 Option의 타입 파라미터는 하나이고 Try는 두개이다. Try는 계산이 실패해도
실패한 정보를 가질 수 있다.

어떤 데이터를 파싱하는 과정 :

> 파싱이라는 작업은 임의의 형식의 데이터를 입력받아서 정해진 데이터 타입으로 변환하는 작업을 의미한다.대표적으로는 JSON.parse 함수가 있다. 성공시 Object, 아니면 예외를 던진다.

indexOf와 같이 실패했다는 사실 그 자체에만 의미가 있고, 추가정보가 필요하지 않을 때는 에러의 상세 내용이
생략되어도 괜찮지만, JSON.parse의 경우에는 실패했다는 사실만 알려주고 이유만 알려주지 않으면 쉽지 않은 상황이 생긴다. 따라서 JSON.parse는 에러의 내용이 매우 중요하고 이것을 전달하여 사용자가 후속작업을 할 수 있도록 한다.

```
Option<A>
에러가 발생했다는 사실만 중요할 때 사용

Try<E,R>
어떤 에러가 발생했는지 그 내용도 중요할 때
```

> Option을 사용하는 경우 Try를 사용하는 것은 문제가 되지 않는다. Try의 에러를 빈문자열의 리터럴 타입처럼 의미없이 사용한다면 상관없다. 특히, Try와 Option을 섞어서 사용하는 것이라면, Undefiend 가 포함된 임의의 타입을 Option으로 변환해서 사용했던 것 처럼 Option 타입을 Try로 변환하는 함수를 만들어두고, Try와 Option을 합성해서 사용하는 것이 가능하다.

그런데 왜 번거롭게 두개를 두고 사용하는가?

```
그 이유는 타입 파라미터가 두개이기 때문에 실제로 사용할 때, 타입 파라미터가 한개인 옵션보다는 신경써야할 것이 더 많아서 그렇다.

정보가 많아지면 신경 써야할 것도 많아진다. 상황에 맞게 필요한 만큼 사용하는 것이 좋다.
```

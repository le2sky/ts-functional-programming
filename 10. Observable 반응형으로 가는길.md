# Observable, 반응형으로 가는길

Observable은 값이 여러 번 전달된다. 반면 Promise는 값이 한 번만 전달된다.
비동기로 전달되는 값이 언제나 한개만 존재하지 않는다. 비동기로 발생하는 값이
언제, 몇번 전달될 지 알 수 없는 상황을 다루기 위해, 반응형이 필요하다.

## 1. Observable 타입

Promise는 콜백함수를 여러번 호출헤서 값은 오직 한번만 전달되는것을 보장 되도록 구현되었다.

> Array 타입의 값은 동시에 여러개의 값을 가지고 있다고 생각할 수 있다.

1 부터 시작되는 연속된 자연수 여러개가 필요하면 값을 다음과 같이 만들 수 있다.
다음과 같이하면 정해진 개수의 값만 사용할 수 있어서 서로 다른 갯수의 자연수가 필요하면 매번 새로 만들어야 한다.

```ts
const ns: Array<number> = [1, 2, 3, 4, 5];
```

숫자를 입력받으면 숫자의 배열을 리턴하는 함수

```ts
const integers = (n: number): Array<number> => {
  const ret: Array<number> = [];
  let i = 0;
  while (i < n) {
    i = i + 1;
    ret.push(i);
  }
  return ret;
};

//아래 함수 일반화

//상태를 갱신하면서 값을 만드는 함수
type Iterator<A> = () => A;

//이터레이터가 사용할 상태를 만들고 초기화 한다음 이터레이터를 생성한다음 돌려줌
type Iterable<A> = () => Iterator<A>;

//요청할 떄마다 다음 자연수 생성 (함수를 리턴)
const integerGenerator = () => {
  let i = 0;
  return () => {
    i = i + 1;
    return i;
  };
};

//입력된 숫자만큼 자연수를 만들어 콘솔에 출력
const onmanyIntegers = (n: number) => {
  const arr = itnegers(n);
  console.log(arr);
};

const onStep = () => {
  const iter = intergerGenerator();
  const n = iter();
  console.log(n);
};
```

위와 같은 상황에서는 1만 출력됨
intergerGenerator가 클릭될 때마다 재실행되어서, 내부 상태가 초기화됨
즉, onStep 밖에서 Generator가 만들어져야함

```ts
const iter = intergerGenerator();
const onStep = () => {
  const n = iter();
  console.log(n);
};
```

비동기 방식

```ts
const promiseIntegers = (n: number): Promise<Array<number>> =>
  new Promise((resolve) => {
    setTimeout(() => {
      const ret: Array<number> = [];
      let i = 0;
      while (i < n) {
        i = i + 1;
        ret.push(i);
      }
      resolve(ret);
    }, 1000);
  });

promiseIntegers(5).then((ns) => console.log(ns));
```

> 단지 달라진건 최종 결과를 리턴하는 것이 아닌 resolve에 전달함, 즉, resolve와 integers 함수를 합성하면 간단해짐

```ts
const promiseIntegers = (n: number): Promise<Array<number>> =>
  new Promise((resolve) => {
    setTimeout(() => {
      resolve(integers(n));
    }, 1000);
  });

promiseIntegers(5).then((ns) => console.log(ns));
```

- 비동기라도 내부적으론 동기적 코드가 있는 경우가 있음 이럴 경우 동기적인 코드는 별도의 함수로 분리하고 비동기 내부에서 적절히 합성해 쓰면 훨씬 단순한 흐름을 가진 코드를 작성할 수 있다.

일정 시간이 지난 후 한번에 여러개의 자연수를 만드는 상황이 아닌 시간이 지날 때 마다 주기적으로 자연수를 만드는 상황, 값이 여러번 발생될 것이기 때문에 resolve를 한번만 실행할 수 있는 promise로는 이 문제를 해결할 수 없다.

```ts
const integerObservable: Async<number> = (ret) => {
  let i = 0;
  setInterval(() => {
    i = i + 1;
    ret(i);
  }, 1000);
};

integerObservable((n) => console.log(n));
```

> integerObservable도 intergerGenerator 와 값을 초기화하고 갱신하는 작업은 동일하다. 다만 값에 갱신을 실행하는 주체가 다르기 떄문에, 값을 실행하는 시점과 전달하는 방식만 차이가 있다. 상태를 초기화하는 코드를 intergerGenerator로 대체해서 iterator를 생성하고, interator를 실행해서 값을 전달하는 것은 setInterval이 동작시키도록 작성하면 된다.

```ts
const integerObservable: Async<number> = (ret) => {
  const iter = integerGenerator();
  setInterval(() => {
    ret(iter());
  }, 1000);
};

integerObservable((n) => console.log(n));
```

> promiseInteger 처럼 비동기 작업내 동기 작업은 분리해서 작성한다.

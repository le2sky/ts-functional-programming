# Observable, 반응형으로 가는길

Observable은 값이 여러 번 전달된다. 반면 Promise는 값이 한 번만 전달된다.
비동기로 전달되는 값이 언제나 한개만 존재하지 않는다. 비동기로 발생하는 값이
언제, 몇번 전달될 지 알 수 없는 상황을 다루기 위해, 반응형이 필요하다.

## 1. Observable 타입 개요

Promise는 콜백함수를 여러번 호출헤서 값은 오직 한번만 전달되는것을 보장 되도록 구현되었다.

> Array 타입의 값은 동시에 여러개의 값을 가지고 있다고 생각할 수 있다.

1 부터 시작되는 연속된 자연수 여러개가 필요하면 값을 다음과 같이 만들 수 있다.
다음과 같이하면 정해진 개수의 값만 사용할 수 있어서 서로 다른 갯수의 자연수가 필요하면 매번 새로 만들어야 한다.

```ts
const ns: Array<number> = [1, 2, 3, 4, 5];
```

숫자를 입력받으면 숫자의 배열을 리턴하는 함수

```ts
const integers = (n: number): Array<number> => {
  const ret: Array<number> = [];
  let i = 0;
  while (i < n) {
    i = i + 1;
    ret.push(i);
  }
  return ret;
};

//아래 함수 일반화

//상태를 갱신하면서 값을 만드는 함수
type Iterator<A> = () => A;

//이터레이터가 사용할 상태를 만들고 초기화 한다음 이터레이터를 생성한다음 돌려줌
type Iterable<A> = () => Iterator<A>;

//요청할 떄마다 다음 자연수 생성 (함수를 리턴)
const integerGenerator = () => {
  let i = 0;
  return () => {
    i = i + 1;
    return i;
  };
};

//입력된 숫자만큼 자연수를 만들어 콘솔에 출력
const onmanyIntegers = (n: number) => {
  const arr = itnegers(n);
  console.log(arr);
};

const onStep = () => {
  const iter = intergerGenerator();
  const n = iter();
  console.log(n);
};
```

위와 같은 상황에서는 1만 출력됨
intergerGenerator가 클릭될 때마다 재실행되어서, 내부 상태가 초기화됨
즉, onStep 밖에서 Generator가 만들어져야함

```ts
const iter = intergerGenerator();
const onStep = () => {
  const n = iter();
  console.log(n);
};
```

비동기 방식

```ts
const promiseIntegers = (n: number): Promise<Array<number>> =>
  new Promise((resolve) => {
    setTimeout(() => {
      const ret: Array<number> = [];
      let i = 0;
      while (i < n) {
        i = i + 1;
        ret.push(i);
      }
      resolve(ret);
    }, 1000);
  });

promiseIntegers(5).then((ns) => console.log(ns));
```

> 단지 달라진건 최종 결과를 리턴하는 것이 아닌 resolve에 전달함, 즉, resolve와 integers 함수를 합성하면 간단해짐

```ts
const promiseIntegers = (n: number): Promise<Array<number>> =>
  new Promise((resolve) => {
    setTimeout(() => {
      resolve(integers(n));
    }, 1000);
  });

promiseIntegers(5).then((ns) => console.log(ns));
```

- 비동기라도 내부적으론 동기적 코드가 있는 경우가 있음 이럴 경우 동기적인 코드는 별도의 함수로 분리하고 비동기 내부에서 적절히 합성해 쓰면 훨씬 단순한 흐름을 가진 코드를 작성할 수 있다.

일정 시간이 지난 후 한번에 여러개의 자연수를 만드는 상황이 아닌 시간이 지날 때 마다 주기적으로 자연수를 만드는 상황, 값이 여러번 발생될 것이기 때문에 resolve를 한번만 실행할 수 있는 promise로는 이 문제를 해결할 수 없다.

```ts
const integerObservable: Async<number> = (ret) => {
  let i = 0;
  setInterval(() => {
    i = i + 1;
    ret(i);
  }, 1000);
};

integerObservable((n) => console.log(n));
```

> integerObservable도 intergerGenerator 와 값을 초기화하고 갱신하는 작업은 동일하다. 다만 값에 갱신을 실행하는 주체가 다르기 떄문에, 값을 실행하는 시점과 전달하는 방식만 차이가 있다. 상태를 초기화하는 코드를 intergerGenerator로 대체해서 iterator를 생성하고, interator를 실행해서 값을 전달하는 것은 setInterval이 동작시키도록 작성하면 된다.

```ts
const integerObservable: Async<number> = (ret) => {
  const iter = integerGenerator();
  setInterval(() => {
    ret(iter());
  }, 1000);
};

integerObservable((n) => console.log(n));
```

> promiseInteger 처럼 비동기 작업내 동기 작업은 분리해서 작성한다.

## 2. Observer과 Observable

Async 타입을 세분화해서 Async의 인자로 받는 타입을 Observer 이라고 정의하고,
Observer은 값을 하나 입력 받는 함수이다. Observable 은 Observer를 인자로 받는다.
보통은 그 인자인 Observer를 Subscribe 라고 부른다.

> 이터러블이 이터레이터를 리턴하는 함수인 반면, Observable은 Observer를 입력받는다. 이터러블은 리턴에 리턴이 연속되어있고, 옵저버블은 입력에 입력이 연속되어있는 형태이다.

```ts
type Async<A> = (ret: (a: A) => void) => void;

// Iterable 내의 상태 갱신과 상태를 기반으로 값을 생성하는 함수
type Iterator<A> = () => A;

// 상태를 초기화하고 iterator를 생성하는 함수
type Iterable<A> = () => Iterator<A>;

//값을 하나 입력받는 타입
type Observer<A> = (a: A) => void;

//옵저버를 입력받는 함수
type Observable<A> = (subscribe: Observer<A>) => void;
```

> 보통은 클래스나 인터페이스로 구현된다. 기본 바탕이 되는 아이디어는 모두 같다.

아래 코드는 우리가 앞에서 정의한 옵저버블을 사용해서 정해진 주기로 자연수를 생성하는 함수이다.

```ts
type Observer<A> = (a: A) => void;
type Observable<A> = (subscribe: Observer<A>) => void;

const isEven = (n: number) => n % 2 === 0;

const integerObservable: Observable<number> = (subscribe) => {
  let i = 0;
  setInterval(() => {
    i = i + 1;
    subscribe(i);
  }, 1000);
};

const ns: Array<number> = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

export const main = () => {};
```

rxjs로 대체하기

```ts
import { Observable } from "rxjs";

const isEven = (n: number) => n % 2 === 0;

const integerObservable: Observable<number> = new Observable((subscribe) => {
  let i = 0;
  setInterval(() => {
    i = i + 1;
    subscribe.next(i);
  }, 1000);
});
```

> Obserable은 값이 여러번 발생될 수 있기 때문에 더이상 발생될 값이 없으면 호출자에게 알려줄 필요가 있어서 complate가 존재한다.

rxjs에서 subscriber는 observer 타입을 확장한다. promise의 resolve는 next에 해당하고, reject는 error에 해당한다.

```ts
export declare class Subscriber<T>
  extends Subscription
  implements Observer<T> {}

export interface Observer<T> {
  next: (value: T) => void;
  error: (err: any) => void;
  complete: () => void;
}
```

여러개의 함수를 인자로 넘기기 불편하니 한곳에 모아서 인터페이스로 만들었을 뿐, 인자를 여러개 쓰는 것과 별반 차이가 없다.

Obserable를 조작하는 함수

만약 짝수를 세개만 가져오고 중단하려면 어떻게 해야하는가?

1. 선언적 방식으로 짝수배열로 만들고, 첫 세개만 가져오는 방법

```ts
export const main = () => {
  const xs = ns
    // ~> : 암시적 인자
    // Array의 메서드이기 때문에 자기자신이 암시적 인자임
    // Array<A> ~> (A => boolean) => Array<A>
    .filter(isEven)
    .slice(0, 3);
  console.log(xs);
};
```

Javascript에서 Array를 조작하는 기능을 메서드로 만들어놓았고, rxjs는 obserable를 조작하는 기능을 함수로 만들었다.

이러한 함수를 operator라고 한다. rxjs의 filter는 함수이기 때문에 독립적으로 호출이 가능하다. 커링된 함수의 마지막 인자로 연산에 사용할 Obserable를 입력받는다.

> 무엇을 필터할 건지 미리 서술해둔다!

take를 사용해서 임의에 Obserable에서 값을 세개 꺼내는 함수를 만든다. evenFilter와 take3는 Obserable를 입력받고 Obserable를 리턴하는 함수이다. rxjs에서는 operator 함수를 합성해주는 함수인 pipe라는 함수를 제공한다.

```ts
import { Observable } from "rxjs";
import { filter } from "rxjs/operators";

export const main = () => {
  // filter :: (A => boolean) => Observable<A> => Observable<A>
  // Observable를 입력받아 Observable를 리턴하는 함수를 operator 라고한다.
  // 커링된 형태의 함수임
  const evenFilter = filter(isEven);
  const take3 = take(3); //Obserable를 입력받아 Obserable를 리턴!

  //Obserable에 특화된 compose 함수라고 볼 수 있다.
  const take3EvenNumbers = pipe(evenFilter, take3);

  take3EvenNumbers(integerObservable).subscribe({
    next: (n) => {
      console.log(n);
    },
  });
};
```
